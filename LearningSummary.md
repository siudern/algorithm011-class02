# 学习总结

## 前言

### 关于面试做题的一些思路
1. clarification  
澄清这个题目所表达的意思，一些细节确认清楚  
2. possible solutions --> optimal (time & space)  
寻找可能的解法，从中找出最优解，分别讲述时间复杂度和空间复杂度  
3. code  
写出最优解法  
4. test cases  
测试样例的阐述 


如何学好数据结构与算法

1. 刻意练习  
基本功是区别业余和职业选手的根本。深厚功底来自于 — 过遍数  
最大的误区：只做一遍  
五毒神掌  
刻意练习 - 练习缺陷弱点地方、不舒服、枯燥  
反馈 - 看题解、看国际版的高票回答  

2.切题四件套  
clarification  明确题⽬意思、边界、数据规模  
possible solutions  穷尽所有可能的解法  
compare（time/space）  
optimal（学习最优解加强）  
coding（多写）代码简洁、⾼性能、美感  
test cases  

3.五毒神掌  
**第一遍**  
五分钟：读题 + 思考  
直接看解法：多看几种，比较解法优劣  
背诵、默写好的解法  
**第二遍**  
马上自己写 ——> Leetcode提交  
多种解法比较、体会 ——> 优化！  
**第三遍**  
过了一天后，再重复做题  
不同解法的熟练程度——>专项练习  
**第四遍**  
过了一周后：反复回来练习相同的题目  
**第五遍**  
面试前一周恢复性训练  


### 一、数据结构  
一维数据结构：  
* 基础：数组array，链表linked list  
* 高级：栈stack，队列queue，双端队列deque，集合set，映射map（hash），等等  

二维数据结构：  
* 树、图、二叉搜索树、红黑树、AVL、堆、并查集、字典树，等等  

特殊：  
* 位运算Bitwise，布隆过滤器BloomFilter  
* LRU Cache  
### 二、算法
#### 本质：  
分支特性  
* if-else, switch   

迭代特性   
* for while loop  

递归特性（函数自调用）   
* Recursion（分治 Divide & Conquer，回溯 Backtrace）     
     
所有的高级算法都会转换成以上三种  

重点：**递归**
递归 – 循环
通过函数体来进行循环
四个条件：

- 递回终止条件
- 处理当前层逻辑
- 下探到下一层
- 清理当前层

**思维要求**

- 不要再进行人肉递归（最大误区）
- 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
- 数学归纳法

**分治思维：**

- 递归终止条件
- 拆分子问题
- 调子问题的递归函数
- 合并结果，有可能要恢复当前层的状态
```go
//分治伪代码
func divideConquer(problem, param1, param2, ...) {
    //中止条件
    if problem == nil {
        print_result
        return
    }
    // 准备数据，处理当前层逻辑
    data = prepare_data(problem)
    subproblems = splitProblem(problem, data)
    //下探到下一层，处理子问题
    subResult1 = divideConquer(subproblems[0], p1, p2, ...)
    subResult2 = divideConquer(subproblems[1], p1, p2, ...)
    subResult3 = divideConquer(subproblems[2], p1, p2, ...)
    ...
    //处理和生成最终结果
    result = processResult(subResult1, subResult2, subResult3, ...)
    //清理当前层状态
}
```

**回溯**  
回溯法采用试错的思想，它尝试分步的去解决一个问题，在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能分步解答再次尝试寻找问题的答案。   
回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：  
* 找到一个可能存在的正确答案  
* 在尝试了所有可能的分步方法后宣告该问题无解  
在最坏情况下，回溯法的时间复杂度是指数级

**深度优先**

**广度优先**

### 贪心算法 Greedy
贪心算法是一种在每一步选择都才去在当前状态下最好或最优解（即最有利）的选择，从而希望使结果也是全局最优解的算法。  
贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能  

贪心：当下做局部最优解  
回溯：能够回退
动态规划：最优判断+回退  

贪心算法可以解决一些最优化问题，如：求图中的最小生成树，求哈夫曼编码等，然而对于工程和生活中的问题，贪心一般不能得到所要求的答案。  
一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决这个问题的最好办法。由于贪心算法的高效性以及其所求得的答案比较接近最优结果，贪心算法也可以做辅助算法或者直接解决一些要求结果不是特别精确的问题。  

贪心算法的适用场景
问题能够分解为子问题  
子问题最优解能递推到最终问题的最优解，这种子问题的最优解称为最优子结构

### 二分查找
首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功  
能用二分查找的条件：  
1. 目标函数单调性（单调递增或递减），即排序后的  
2. 存在上下界（bounded）  
3. 能够通过索引访问（index accessible）  

代码模板
```go
func BinarySearch(n []int, target int) int {
    length := len(n)   
    low := 0   
    high := length - 1
    for low <= high {
         mid := (low + high) / 2      
         if n[mid] > target {
             high = mid - 1
         } else if n[mid] < target {
             low = mid + 1      
         } else {         
             return mid      
         }   
    }
    return -1
} 
```
**动态规划**
动态规划的特点：
分治 + 最优子结构

动态规、递归、分治，没有本质上的区别（关键看有无最优子结构）  
共性：找到重复子问题  
差异性：最优子结构、中途可以淘汰次优解  

状态转移方程 DP
```python
opt[i, j] = opt[i+1, j] + opt[i, j+1]
# 完整逻辑：
if a[i, j] = "空地"
    opt[i, j] = opt[i+1, j] + opt[i, j+1]
else:
    opt[i, j] = 0
```

动态规划关键点  
1. 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2], ...)  
2. 存储中间状态opt[i]  
3. 递推公式（状态转移方程，或者叫DP方程）  
  fib：opt[i] = opt[n-1] + opt[n-2]  
  二维路径：opt[i,j] = opt[i+1, j] +opt[i, j+1] 且判断opt[i, j]是否为空  


动态规划小结  
1. 打破自己的思维惯性，形成机器思维  
2. 理解复杂逻辑的关系  


## 字典树 Trie
1、字典树的树结构  
* 字典树，即Trie树，又称单词查找树或键树，是一种属性结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计  
* 优点：最大限度减少无所谓的字符串比较，查询效率比哈希高  
* 多叉树  

2、字典树的核心思想  
* 空间换时间  
* 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的

3、字典树的基本性质  
* 节点本身不存完整单词  
* 从根节点到某一节点，路径上锁经过的字符连起来，为该节点对应的字符串  
* 每个节点的所有子节点路径代表的字符都不相同  
```python
class Trie(object):
    def __init__(self):
        self.root = {}
        self.end_of_word = "#"

    def insert(self, word):
        node = self.root
        for char in word:
            node = node.setdefault(char, {})
        node[self.end_of_word] = self.end_of_word

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node:
                return False
            node = node[char]
        return self.end_of_word in node

    def startswith(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node:
                return False
        return True
```

### 并查集 Disjoint Set
使用场景：  
组团、配对问题  
group or not  

基本操作：  
* make Set(s)：建立一个新的并查集，其中包含S个单元素集合。
* union Set（x, y)：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。
* find(x)：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了

### 高级搜索
* 剪枝
* 双向BFS
* 启发式搜索（A*)

初级搜索：
1. 朴素搜索
2. 优化方式：不重复（fibonacci）、剪枝（生成括号问题）
3. 搜索方向：
   * DFS
   * BFS
   双向搜索、启发式搜索

启发式函数：h(n)，它用来评价哪些节点最优希望的是一个我们要找的节点，h(n)会返回一个非负整数，也可以认为是从节点n的目标节点路径的估计成本  
启发式函数是一种告知搜索方向的方法，它提供了一种明智的方法来猜测哪个邻居节点会导向一个目标  

### 高级树、AVL树和红黑树

#### AVL:
Balance Factor（平衡因子）：  
是它左子树的高度减去它右子树的高度（有时相反）。  
balance factor {-1,0,1}  
旋转操作
1. 左旋
2. 右旋
3. 左右旋
4. 右左旋

总结
1. 平衡二叉树搜索
2. 每个节点存balance factor = {-1,0,1}
3. 四种旋转操作
不足：节点需要存储额外信息，且调整次数频繁  

#### 红黑树
红黑树是一种近似平衡的二叉搜索树，他能够确保任何一个节点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉搜索树
* 每个节点要么是红色，要么是黑色
* 根节点是黑色
* 每个叶子节点（NIL节点，空节点）是黑色。
* 不能有相邻的两个红色节点
* 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点


## 位运算

位运算符  
算数位移与逻辑位移  
位运算的应用  

机器中的数字表示方式和存储格式都是二进制  
位运算符:  
* 左移： <<  
0011 -> 0110  
* 右移： >>  
0110 ->  0011  
* 按位或：|，一一对比，只要有一方为1，就是1，两个都是0才为0  
0011和1011得出1011  
* 按位与：%，一一对比，只要有一方为0，就是0，两个都是1才为1，和上面相反  
0011和1011得出0011  
* 按位取反：~，1变成0，0变成1  
0011得出1100  
* 按位异或：^，一一对比，相同为0，不同为1  
0011余1011得出1000  


### 异或：相同为0，不同为1。也可用"不进位加法"来理解  
异或操作特点：  
x ^ 0 = x  
x ^ 1s= ~x  注意1s = ~0  
x ^ (~x) = 1s  
x ^ x = 0  
c = a ^ b => a ^ c = b, b ^ c = a  交换两个数  
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c  

### 指定位置的位运算
将x最右边的n位清零：x & (~ 0 << n)  
获取x的第n位值（0或者1）：x >> n & 1  
获取x的第n位的幂值： x & (1 << n)  
仅将第n位置为1：x | (1 << n)  
仅将第n位置为0：x & (~(1 << n))  
将x最高位至第n位（含）清零：x & ((1 << n) - 1)  

### 实战位运算要点
* 判断奇偶：  
x%2 == 1   -> (x&1) == 1  转换我二进制之后往右移一位
x%2 == 0   -> (x&1) == 0  
* x >> 1  -> x/2  
即：x = x/2  ->  x = x >> 1  
mid = (left + right)/2  ->  mid = (left + right) >> 1  
* 清零最低位的1  
x = x & (x - 1 )  
* 得到最低位的1  
x = x & -x  
* 零值  
x & ~x = 0  

## 布隆过滤器
一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索 一个元素是否在一个集合中。  
优点是空间效率和查询时间都远远超过一般的算法， 缺点是有一定的误识别率和删除困难。  

1. 比特币网络  
2. 分布式系统(Map-Reduce) — Hadoop、search engine  
3. Redis 缓存  
4. 垃圾邮件、评论等的过滤  



