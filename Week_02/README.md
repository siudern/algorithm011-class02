# 学习笔记

### 哈希表、映射、集合
####  哈希表

哈希表（Hash table），也叫散列表，是根据关键码值（key value）而直接进行访问的数据结构。  
他通过把关键码值映射到表中一个位置来访问记录，以加快查找速度。  
这个映射函数叫做散列函数（Hash Function），存放记录的数组叫做哈希表（或散列表）  

哈希在一定情况下会产生冲突，是在计算之后最终取的hash值产生重复，这种冲突叫做哈希碰撞  
处理冲突的方法：  
1、开放定址法  
2、拉链法：  
拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中，若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组t[0..m-1]。凡是散列地址为i的结点，均插入到以t为头指针的单链表中。t中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1
3、建立公共溢出区

查询添加删除时间复杂度都是O(1)，极端情况下都是O(n)



#### 映射
Map：key-value对，key不重复


#### 集合
Set：不重复元素集合

### 树、二叉树、二叉搜索树
树里面的查找就要利用到**递归**的思想  
#### 树
查询和操作时间复杂度O(logN)  
图形化演示环境：https://visualgo.net/zh/bst  
删除操作：分两种（一种是删除叶子节点，一种是删除关键节点）  
叶子节点直接删除  
关键节点，需要找到待删除节点的值最接近的小于它的节点，或者是待删除节点的值最接近的大于它的节点，（最接近的元素值，不是最接近的元素节点）  
极端情况下，树退化成链表，无限向左或者无限向右，复杂度退化成O(n)，所以要对其重新进行平衡
相当于一个单链表有多个指针，指向多个下一节点，就形成了树  
二叉树：儿子节点只有两个
树的查找一般都是递归  
树和图最大的差别就是看有没有环，如果有环就形成了图  

递归有什么特点：  
1.可以被分解成重复的子问题  
2.子问题可以使用相同的算法来解决  
3.有明确的终止条件  

树为什么用递归：  
1.树的结构与递归类似，递归的自调用就相当于让树的子树们再进行一次同样的操作  
2.递归的代码结构更加简单明了，也是树这么一个高维数据结构所带来的优势之一  
3.对于一种数据结构来说，无非就是查找插入和删除，在进行遍历这个反复循环的动作时，对于树的结构来说递归非常实用  

LinkedList（链表）是特殊化的Tree（树） 
Tree（树）是特殊化的Graph（图） 

#### 二叉树遍历
1. 前序（Pre-order）：根-左-右  
2. 中序（In-order）：左-根-右  
3. 后序（Post-order）：左-右-根  

#### 二叉搜索树
二叉搜索树，也称二叉排序树、有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree），是指一颗空树或者具有下列性质的二叉树：  
1. 左子树上**所有节点**的值均小于他根节点的值；  
2. 右子树上**所有节点**的值均大于他根节点的值；  
3. 以此类推：左、右子树也分别为二叉查找树。（重复性） 
中序遍历：是升序排列

###  堆、二叉堆、图
#### 堆 Heap
Heap 堆：可以迅速找到一堆数中的最大或者最小值的数据结构，是一种抽象的数据结构  
将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆  
要么找最大值，要么找最小值，无法同时实现  
常见的堆有二叉堆、斐波那契堆（可以实现O(1)的插入时间复杂度）等。  
堆的实现有很多种，只是二叉堆相对来说比较好实现，还有更牛批的堆
假设是大顶堆，则常见操作：
find-max： O(1）
delete-max： O(logN)
insert（create）：O(logN)或者O(1)  
应用场景： 比如任务流，随时取出优先级最高的任务去处理  

#### 二叉堆性质
注意：二叉堆是堆（优先队列priority_queue）的一种常见且简单的实现；但并不是最优的实现（不实用）
通过完全二叉树来实现（注意：不是二叉搜索树）
完全二叉树：除了叶子节点可以不满以外，其他节点的子节点都是2个
二叉堆（大顶）满足下列性质：
1. 是一颗完全树：
2. 树中任意节点的值总是大于等于其子节点的值

#### 二叉堆实现细节
1. 二叉堆一般通过"数组"实现  
2. 假设"第一个元素"在数组中的索引为0：  
则父节点的和子节点的位置关系如下：  
 * 索引为i的左子节点的索引是（2*i+1)  
 * 索引位i的右子节点的索引是（2*i+2)  
 * 索引为i的父亲节点的索引是floor((i-1)/2)  
 
##### 二叉堆的insert操作  
时间复杂度：O(logN)
1. 新元素一律插入到堆的尾部
2. 依次向上调整堆的结构（一直到根即可），比较大小一直到根，一直向上浮（类似冒泡）。 HeapifyUp  
##### 二叉堆的delete操作
时间复杂度：O(logN)
1. 把堆尾的元素放到堆顶（即堆顶被替代删除掉）  
2. 依次从根部向下调整堆的结构（一直到堆尾即可），替换子节点中较大的那个 HeapifyDown




## 关于面试做题的一些思路
1. clarification  
澄清这个题目所表达的意思，一些细节确认清楚  
2. possible solutions --> optimal (time & space)  
寻找可能的解法，从中找出最优解，分别讲述时间复杂度和空间复杂度  
3. code  
写出最优解法  
4. test cases  
测试样例的阐述  



