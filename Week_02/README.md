# 学习笔记

### 哈希表、映射、集合
####  哈希表

哈希表（Hash table），也叫散列表，是根据关键码值（key value）而直接进行访问的数据结构。  
他通过把关键码值映射到表中一个位置来访问记录，以加快查找速度。  
这个映射函数叫做散列函数（Hash Function），存放记录的数组叫做哈希表（或散列表）  



#### 映射


#### 集合


### 树、二叉树、二叉搜索树
树里面的查找就要利用到**递归**的思想
#### 树
查询和操作时间复杂度O(logN)  
图形化演示环境：https://visualgo.net/zh/bst  
删除操作：分两种（一种是删除叶子节点，一种是删除关键节点）  
叶子节点直接删除  
关键节点，需要找到待删除节点的值最接近的小于它的节点，或者是待删除节点的值最接近的大于它的节点，（最接近的元素值，不是最接近的元素节点）  
极端情况下，树退化成链表，无限向左或者无限向右，复杂度退化成O(n)，所以要对其重新进行平衡
相当于一个单链表有多个指针，指向多个下一节点，就形成了树  
二叉树：儿子节点只有两个
树的查找一般都是递归  
树和图最大的差别就是看有没有环，如果有环就形成了图  

LinkedList（链表）是特殊化的Tree（树） 
Tree（树）是特殊化的Graph（图） 

#### 二叉树遍历
1. 前序（Pre-order）：根-左-右  
2. 中序（In-order）：左-根-右  
3. 后序（Post-order）：左-右-根  

#### 二叉搜索树
二叉搜索树，也称二叉排序树、有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree），是指一颗空树或者具有下列性质的二叉树：  
1. 左子树上**所有节点**的值均小于他根节点的值；  
2. 右子树上**所有节点**的值均大于他根节点的值；  
3. 以此类推：左、右子树也分别为二叉查找树。（重复性） 
中序遍历：是升序排列

###  堆、二叉堆、图
#### 堆 Heap
Heap 堆：可以迅速找到一堆数中的最大或者最小值的数据结构，是一种抽象的数据结构  
将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆  
要么找最大值，要么找最小值，无法同时实现  
常见的堆有二叉堆、斐波那契堆（可以实现O(1)的插入时间复杂度）等。  
堆的实现有很多种，只是二叉堆相对来说比较好实现，还有更牛批的堆
假设是大顶堆，则常见操作：
find-max： O(1）
delete-max： O(logN)
insert（create）：O(logN)或者O(1)  
应用场景： 比如任务流，随时取出优先级最高的任务去处理  

#### 二叉堆性质
注意：二叉堆是堆（优先队列priority_queue）的一种常见且简单的实现；但并不是最优的实现（不实用）
通过完全二叉树来实现（注意：不是二叉搜索树）
完全二叉树：除了叶子节点可以不满以外，其他节点的子节点都是2个
二叉堆（大顶）满足下列性质：
1. 是一颗完全树：
2. 树中任意节点的值总是大于等于其子节点的值

#### 二叉堆实现细节
1. 二叉堆一般通过"数组"实现  
2. 假设"第一个元素"在数组中的索引为0：  
则父节点的和子节点的位置关系如下：  
 * 索引为i的左子节点的索引是（2*i+1)  
 * 索引位i的右子节点的索引是（2*i+2)  
 * 索引为i的父亲节点的索引是floor((i-1)/2)  
 
##### 二叉堆的insert操作  
时间复杂度：O(logN)
1. 新元素一律插入到堆的尾部
2. 依次向上调整堆的结构（一直到根即可），比较大小一直到根，一直向上浮（类似冒泡）。 HeapifyUp  
##### 二叉堆的delete操作
时间复杂度：O(logN)
1. 把堆尾的元素放到堆顶（即堆顶被替代删除掉）  
2. 依次从根部向下调整堆的结构（一直到堆尾即可），替换子节点中较大的那个 HeapifyDown




## 关于面试做题的一些思路
1. clarification  
澄清这个题目所表达的意思，一些细节确认清楚  
2. possible solutions --> optimal (time & space)  
寻找可能的解法，从中找出最优解，分别讲述时间复杂度和空间复杂度  
3. code  
写出最优解法  
4. test cases  
测试样例的阐述  



